# 開発ワークフロー (DEVELOPMENT WORKFLOW)

本ドキュメントは、本プロジェクトにおける開発ワークフローやAIの行動規範について定義します。

## 1. ビルドチェックと品質保証

プロジェクトの品質を維持するため、以下のビルドチェックと品質保証に関するルールを遵守しなければなりません。

-   **セットアップ:** 開発環境のセットアップは `npm install` を実行するだけで完了します。E2Eテストに必要なPlaywrightのブラウザなども、このコマンドで自動的にインストールされます。
    **CI環境では、依存関係の厳密な管理のため `npm ci` を使用します。**

-   **ローカルでの事前確認:** 変更をコミットする前に、必ず以下のコマンドを実行し、ビルド、リンティング、型チェック、**およびすべてのテスト**が正常に完了することを確認しなければなりません。
    ```bash
    npm run build
    npm run lint
    npm test
    npm run e2e
    ```
    **ローカルPC、CI環境、Jules開発エージェントなど、異なる環境での動作差異を常に意識してください。**
    特に、Jules開発エージェントのようなヘッドレス環境では、Playwrightのブラウザ起動オプションなど、環境固有の設定が必要になる場合があります。

-   **プッシュ前フック:** `husky` を使用して、リモートリポジトリにプッシュする前に、プロジェクト全体のテスト（ユニットテスト、E2Eテスト）、リンティング、ビルドが自動的に実行されるように設定されています。これにより、品質基準を満たさないコードがリポジトリにプッシュされることを防ぎます。

-   **CI/CD連携:**
    -   **プルリクエストチェック:** GitHub Actionsの `pr-checks.yml` ワークフローにより、プルリクエストが作成または更新されるたびに、テスト、リンティング、ビルドが自動的に実行され、コードの品質が検証されます。
        **このワークフローでは `npm ci` を使用し、依存関係の整合性を保証します。**
    -   **デプロイ:** GitHub Actionsの `deploy.yml` ワークフローにより、`main` ブランチへのマージ後にプロジェクトがビルドされ、GitHub Pagesにデプロイされます。
        **このワークフローでも `npm ci` を使用します。**

## 2. 基本的なワークフロー (Git & PR)

-   **ブランチ:** 新規タスクの開始時、AIは人間の指示に基づき、適切な名前でフィーチャーブランチを作成します。
-   **コミット:** 作業の区切りで、AIは変更内容を要約したコミットメッセージ（日本語）を作成し、人間の承認を得てコミットを実行します。
-   **プッシュ:** AIは人間の指示に基づき、現在のブランチをリモートにプッシュします。
-   **PR提案:** プッシュが完了した後、AIは作業内容を要約したPRのタイトルと本文を自発的に提案します。
-   **言語:** コミットメッセージ、および本プロジェクトで作成されるすべてのドキュメントは、原則として日本語で記述します。

### 2.1. AIの標準作業フロー

AIは、人間からタスクの指示を受けた際、以下の標準作業フローを厳守します。これにより、コードとドキュメントの整合性を保ち、作業の透明性と再現性を確保します。

1.  **タスクの理解と計画:**
    *   ユーザーからの指示を完全に理解します。
    *   関連する既存ドキュメント（技術ガイド、仕様書など）を読み込み、現状と制約を把握します。
    *   作業計画を立てます。この際、コード変更とドキュメント更新の依存関係を明確にします。

2.  **ブランチの作成:**
    *   新しいフィーチャーブランチを適切な命名規則で作成します。

3.  **変更の実装:**
    *   計画に基づき、コードの変更とドキュメントの更新を並行して進めます。
    *   **重要:** コード変更と関連するドキュメント更新は、常に同じ論理的な単位で完了させます。

4.  **ローカルでの検証:**
    *   変更が完了したら、`npm test`、`npm run lint`、`npm run build` を実行し、ローカルで全てのチェックがパスすることを確認します。
    *   必要に応じて、手動での動作確認も行います。

5.  **変更のステージングとコミット:**
    *   `git status` を実行し、**現在のブランチが意図したフィーチャーブランチであることを必ず確認します。**
    *   変更されたファイルを `git add` でステージングします。この際、**コミットに含めるべきファイルのみ**を正確にステージングします。一時ファイルや生成ファイルは含めません。
    *   コミットメッセージは、変更内容を明確に記述し、関連するドキュメントの更新も言及します。
    *   コミット後、`.git_commit_message.txt` のような一時ファイルが残っていないか確認し、残っていれば削除します。

6.  **リモートへのプッシュ:**
    *   フィーチャーブランチをリモートリポジトリにプッシュします。

7.  **プルリクエストの作成（提案）:**
    *   プッシュが完了したら、プルリクエストのタイトルと本文を提案します。

8.  **ログの更新:**
    *   セッションの最後に、`docs/logs/activities/` および必要に応じて `docs/logs/decisions/` に作業内容のサマリーを追記します。

## 4. ログの管理と責務

プロジェクトの透明性と再現性を確保するため、ログは以下の新しい構造で管理します。これにより、情報の検索性と管理の容易性を向上させます。

### 4.1. ログの種類と保存場所

ログは、その内容と目的によって以下のディレクトリに保存されます。ファイル名は `YYYY-MM-DD_タイトル.md` の形式とします。

-   **意思決定ログ (`docs/logs/decisions/`)**
    -   **目的:** **なぜ**その決定をしたのか、という**理由**と**背景**を記録する。
    -   **内容:** 設計上のトレードオフ、導入技術の選定理由、ワークフローの変更理由など、将来参照すべきハイレベルな意思決定を記録する。
    -   **AIの責務:** 重要な意思決定が行われたセッションの最後に、その内容を要約し、新しいファイルとして追記を自発的に提案しなければならない。

-   **活動ログ (`docs/logs/activities/`)**
    -   **目的:** **なにを**したのか、という具体的な**作業の事実**を時系列で記録する。
    -   **内容:**
        -   **システム全体に関わる作業 (`docs/logs/activities/system/`)**: プロジェクト全体のビルド、テスト、デプロイなど。
        -   **特定のゲームに関する作業 (`docs/logs/activities/games/[slug]/`)**: 各ゲームの実装、バグ修正など。
    -   **AIの責務:** 作業を行った**すべてのセッションの最後**に、その日の作業内容のサマリーを適切なディレクトリに新しいファイルとして追記しなければならない。

### 4.2. ログ追記の厳格な手順

ログファイルへの追記を行う際、AIは**必ず**以下の手順を実行しなければならない。ファイルの直接的な上書きによる情報損失は、重大なルール違反とみなす。

1.  **適切なログの種類とディレクトリを判断する。**
2.  **ファイル名を `YYYY-MM-DD_タイトル.md` の形式で決定する。**
3.  **`write_file` を使用し、新しいファイルとして内容を書き込む。** (既存ファイルへの追記ではなく、常に新しいファイルを作成する)

## 5. 未解決問題と課題の管理

プロジェクトの健全性を維持し、議論中に発生した未解決の問題や将来の課題が失われることを防ぐため、AIは以下の責務を負う。

-   **AIの責務:**
    -   タスクの完了時、またはセッションの終了時、AIはこれまでの議論をレビューし、**未解決の疑問、将来のタスク、または特定されたが即座に対処されなかった問題**がないかを確認しなければならない。
    -   そのような項目が発見された場合、AIは**自発的にGitHub Issueの作成を提案しなければならない。** 提案には、Issueのドラフトタイトルと説明文を含めること。
