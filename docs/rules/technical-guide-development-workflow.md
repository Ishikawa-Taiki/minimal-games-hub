# 開発ワークフロー (DEVELOPMENT WORKFLOW)

本ドキュメントは、本プロジェクトにおける開発ワークフローやAIの行動規範について定義します。

## 1. npmスクリプトの規約 (npm Script Conventions)

プロジェクトの一貫性と自動化の信頼性を高めるため、すべての開発者およびAIエージェントは以下の規約を厳守してください。

-   **命名規則:** `package.json`のスクリプトは、`動詞:対象`の形式で命名します。
    -   例: `test:unit`, `update:license`
-   **実行の徹底:** CI/CD、gitフック、AIエージェントによる自動化タスクの実行は、必ず`npm run <script-name>`の形式で行わなければなりません。
    -   `npx vitest`や`next build`のような、パッケージの実行ファイルを直接呼び出すコマンドは使用しないでください。
    -   これにより、すべてのタスク実行が`package.json`に集約され、将来の変更が容易になります。
-   **親スクリプト:** 関連する複数のスクリプトをまとめて実行するために、親スクリプトを定義することができます。
    -   例: `test`スクリプトは、`test:unit`、`test:e2e`、`test:license`をすべて実行します。

## 2. ビルドチェックと品質保証

プロジェクトの品質を維持するため、以下のビルドチェックと品質保証に関するルールを遵守しなければなりません。

### 2.0. ビルド失敗時の対応原則

pushやCI/CDでビルドが失敗した場合、効率的な問題解決のため以下の原則を遵守すること：

-   **2回以上の失敗回避:** 同じ種類のエラーで2回以上失敗した場合は、pushによる確認を停止し、ローカルで問題を完全に解決してからコミット・pushを行う。
-   **ローカルでの事前確認:** 修正後は必ず以下のコマンドをローカルで実行し、すべてが正常に完了することを確認する：
    ```bash
    npm run build  # TypeScriptビルドエラーの確認
    npm test       # 全テストの実行
    ```
-   **段階的な修正:** 複数の問題が同時に発生している場合は、一つずつ段階的に修正し、各段階でローカル確認を行う。
-   **型エラーの優先対応:** TypeScriptの型エラーは他のエラーの原因となることが多いため、最優先で対応する。

### 2.1. TDDベースの機能追加

機能追加や改修を行う際は、以下のTDD（テスト駆動開発）ベースのワークフローを推奨します。これにより、変更による手戻りやデバッグの困難さを回避し、品質と開発効率の向上を目指します。

1.  **テストの記述:**
    *   追加する機能の最小単位に対して、まず失敗するテストを記述します。
    *   テストは、その機能が満たすべき要件を明確に表現するものであるべきです。
2.  **テストの実行と失敗の確認:**
    *   記述したテストを実行し、意図通りに失敗することを確認します。
3.  **コードの実装:**
    *   テストをパスするために必要最小限のコードを実装します。
4.  **テストの実行と成功の確認:**
    *   テストを実行し、成功することを確認します。
5.  **リファクタリング:**
    *   コードの品質を向上させるためにリファクタリングを行います。この際、テストが引き続きパスすることを確認します。
6.  **繰り返す:**
    *   次の機能の最小単位に対して、このサイクルを繰り返します。

-   **セットアップ:** 開発環境のセットアップは `npm install` を実行するだけで完了します。
    **CI環境では、依存関係の厳密な管理のため `npm ci` を使用します。**

-   **ローカルでの事前確認:** 変更をコミットする前に、必ず以下のコマンドを実行し、ビルド、リンティング、型チェック、**およびすべてのテスト**が正常に完了することを確認しなければなりません。
    **新しい機能を追加した場合は、その機能に対する新しいテストを作成し、それらのテストもこの時点でパスする必要があります。**
    ```bash
    npm test
    npm run build
    ```
    **ローカルPC、CI環境、Jules開発エージェントなど、異なる環境での動作差異を常に意識してください。**
    特に、Jules開発エージェントのようなヘッドレス環境では、Playwrightのブラウザ起動オプションなど、環境固有の設定が必要になる場合があります。

-   **プッシュ前フック:** `husky` を使用して、リモートリポジトリにプッシュする前に、プロジェクト全体のテスト（ユニットテスト、E2Eテスト）、リンティング、ビルドが自動的に実行されるように設定されています。

-   **CI/CD連携:**
    -   **プルリクエストチェック:** GitHub Actionsの `pr-checks.yml` ワークフローにより、プルリクエストが作成または更新されるたびに、テスト、リンティング、ビルドが自動的に実行され、コードの品質が検証されます。
        **このワークフローでは `npm ci` を使用し、依存関係の整合性を保証します。**
    -   **デプロイ:** GitHub Actionsの `deploy.yml` ワークフローにより、`main` ブランチへのマージ後にプロジェクトがビルドされ、GitHub Pagesにデプロイされます。
        **このワークフローでも `npm ci` を使用します。**

## 3. 基本的なワークフロー (Git & PR)

-   **ブランチ:** 新規タスクの開始時、AIは人間の指示に基づき、適切な名前でフィーチャーブランチを作成します。
-   **コミット:** 作業の区切りで、AIは変更内容を要約したコミットメッセージ（日本語）を作成し、人間の承認を得てコミットを実行します。
    -   **コミットメッセージの包括性:** コミットメッセージは、セッションの最後のやり取りだけでなく、タスクの開始から完了までの作業全体を要約した、包括的な内容にすること。
-   **プッシュ:** AIは人間の指示に基づき、現在のブランチをリモートにプッシュします。
-   **PR提案:** プッシュが完了した後、AIは作業内容を要約したPRのタイトルと本文を自発的に提案します。
-   **言語:** コミットメッセージ、プルリクエストのタイトルと本文、および本プロジェクトで作成されるすべてのドキュメントは、原則として日本語で記述します。

### 2.2. AIの標準作業フロー

AIは、人間からタスクの指示を受けた際、以下の標準作業フローを厳守します。これにより、コードとドキュメントの整合性を保ち、作業の透明性と再現性を確保します。

1.  **タスクの理解と計画:**
    *   ユーザーからの指示を完全に理解します。
    *   関連する既存ドキュメント（技術ガイド、仕様書など）を読み込み、現状と制約を把握します。
    *   作業計画を立てます。この際、コード変更とドキュメント更新の依存関係を明確にします。
    *   疑問点があれば、解決するまで人間（ユーザー）にヒアリングを行うこと。

2.  **ブランチの作成:**
    *   新しいフィーチャーブランチを適切な命名規則で作成します。

3.  **変更の実装とログのリアルタイム更新:**
    *   計画に基づき、コードの変更とドキュメントの更新を並行して進めます。
    *   **重要:** コード変更と関連するドキュメント更新は、常に同じ論理的な単位で完了させます。
    *   **ログのリアルタイム更新:** 作業の進捗や方針変更、重要な決定事項は、会話の区切りごとにリアルタイムでログ（`docs/logs/activities/` および `docs/logs/decisions/`）に整理して記載すること。これにより、コミット時にはログ情報も一緒にコミットされる状態を維持する。

4.  **ローカルでの検証:**
    *   変更が完了したら、`npm test` と `npm run build` を実行し、ローカルで全てのチェックがパスすることを確認します。
    *   必要に応じて、手動での動作確認も行います。

5.  **変更のステージングとコミット:**
    *   `git status` を実行し、**現在のブランチが意図したフィーチャーブランチであることを必ず確認します。**
    *   変更されたファイルを `git add` でステージングします。この際、**コミットに含めるべきファイルのみ**を正確にステージングします。一時ファイルや生成ファイルは含めません。
    *   コミットメッセージは、変更内容を明確に記述し、関連するドキュメントの更新も言及します。
    *   コミット後、`.git_commit_message.txt` のような一時ファイルが残っていないか確認し、残っていれば削除します。

6.  **リモートへのプッシュ:**
    *   フィーチャーブランチをリモートリポジトリにプッシュします。

7.  **プルリクエストの作成（提案）と残課題の棚卸し:**
    *   プッシュが完了したら、プルリクエストのタイトルと本文を提案します。
    *   その後、プロジェクトが宿題とすべき残対応がプロンプト中に発生しなかったかをおさらいし、あればIssue化するためのタイトルや本文情報を共有すること。

8.  **ドキュメント更新の確認:**
    *   タスク完了時、またはセッション終了時、AIは以下の質問に自問自答し、必要に応じてドキュメントを更新します。
        *   「今回のタスクで、新しい技術的知見や意思決定はありましたか？」
        *   「過去のドキュメントやコードの理解に、通常より時間がかかった箇所はありましたか？その原因は何でしたか？」
        *   「将来の自分（AI）や人間が、このタスクを再開する際に、追加で知っておくべき情報はありますか？」
        *   「今回のタスクで、既存のドキュメント（技術ガイド、仕様書など）の更新が必要な箇所はありましたか？」
    *   これらの質問に対する回答に基づき、意思決定ログや技術ガイドの更新を提案します。

-   **自己分析と改善提案:**
    AIは、ユーザーからの要求に対する応答に通常よりも時間がかかったと判断した場合、その要因を自己分析します。分析の結果、作業効率の改善に繋がる可能性のある提案（例：コードのコンポーネント分割、テスト戦略の見直しなど）を自発的に行い、開発プロセスの継続的な改善に貢献します。

### 2.3. AIの問題解決フロー

AIは、タスクの実行中やテストの失敗など、予期せぬ問題に直面した場合、以下のフローに従って問題解決を試みます。このフローは、問題の迅速な特定と解決、および過去の知見の活用を目的としています。

1.  **問題の初期分析:**
    *   エラーメッセージ、スタックトレース、テストレポートなどを詳細に確認し、問題の性質（ビルドエラー、テスト失敗、ランタイムエラーなど）と発生箇所を特定します。
    *   問題が特定の環境（例: `pre-push`フック）でのみ発生するかどうかを確認します。

2.  **関連ドキュメントの参照:**
    *   問題の性質に応じて、関連する技術ガイド（例: `technical-guide-development-workflow.md`のテスト関連セクション）を参照し、問題解決のヒントや既存のルールを確認します。

3.  **過去の意思決定ログの調査:**
    *   `docs/logs/decisions/`ディレクトリ内の意思決定ログを調査します。特に、エラーメッセージや問題のキーワードに関連するログを検索し、過去に類似の問題がどのように解決されたか、どのような試行錯誤があったかを確認します。
    *   **検索のヒント:**
        *   エラーメッセージのキーワード
        *   関連するファイル名や機能名
        *   過去のコミットメッセージ
    *   ログから得られた情報に基づき、問題の原因や解決策の仮説を立てます。

4.  **過去の活動ログの調査:**
    *   必要に応じて、`docs/logs/activities/`ディレクトリ内の活動ログを調査し、特定の機能や修正がどのように実装されたか、その過程でどのような問題が発生したかを確認します。

5.  **解決策の検討と実行:**
    *   ドキュメントやログから得られた情報に基づき、問題解決のための具体的なアプローチを検討します。
    *   複数のアプローチが考えられる場合は、それぞれのメリット・デメリットを評価し、最も効果的かつ安全な方法を選択します。
    *   選択したアプローチを実行し、問題が解決したかを確認します。

6.  **問題が解決しない場合:**
    *   上記フローを繰り返しても問題が解決しない場合、または新たな問題が発生した場合は、その時点での状況、試したこと、得られた情報、および次のステップの提案を人間（ユーザー）に報告し、指示を仰ぎます。

7.  **知見のドキュメント化:**
    *   問題が解決した場合、または以下のいずれかの条件に合致した場合、その知見を意思決定ログ（`docs/logs/decisions/`）または関連する技術ガイドに追記し、将来の参照に役立てます。
        *   **重要な意思決定があった場合:** 技術的な選択、方針転換、設計判断など、プロジェクトの将来に影響を与える決定。
        *   **試行錯誤の末に解決した問題:** 解決までに複数のアプローチを試した、または予期せぬ困難に直面した問題。
        *   **過去のドキュメントやコードの理解に時間を要した場合:** 既存のドキュメントやコードが不明瞭で、その理解に通常より時間を要した原因と、その解決策。
        *   **将来の作業に役立つと判断される知見:** 特定のツール、ライブラリ、フレームワークの挙動に関する深い洞察、または特定の環境（例: `pre-push`フック）でのみ発生する問題の解決策。
    *   **ドキュメント化する内容の原則:**
        *   **課題:** 何が問題だったのか、明確に記述する。
        *   **却下した見解と理由:** 試したアプローチとその結果、なぜそのアプローチが却下されたのかを具体的に記述する。
        *   **最終決定:** 採用された解決策とその理由。
        *   **得られた知見:** 解決策から得られた教訓や洞察。
        *   **今後の指針:** 同様の課題に直面した場合の推奨されるアプローチや注意点。
    *   **参照先との連携:** 記録した知見が、将来的にどのドキュメント（例: `technical-guide-development-workflow.md`の関連セクション）から参照されるべきかを意識し、必要に応じてそのドキュメントへの追記も提案します。

## 4. テスト実装の方針 (Testing Implementation Policy)

プロジェクトのテストは、CI/CD環境での安定性と迅速なフィードバックを重視し、以下の原則に従う必要があります。

### 4.1. タイムアウトに依存しないアサーション

テスト、特にE2Eテストでは、Playwrightの `expect` が持つ自動リトライ機能によるタイムアウト（デフォルト5000ms）に可能な限り依存しないように実装します。これは、要素の表示や状態の変化を待つことによるテストの不安定化や、CI環境でのエラー検知の遅延を防ぐためです。

**原則として、以下のアプローチを推奨します:**

1.  **値の取得と直接比較:**
    `locator.textContent()` や `locator.inputValue()` などで値を取得します。
2.  **即時評価されるマッチャーの使用:**
    取得した値を `vitest` の `expect(...).toBe(...)` や `expect(...).toEqual(...)` のような、リトライ機能を持たないマッチャーで検証します。

この方針により、テストは意図しない状態を即座に検知し、開発サイクルを高速化します。

### 4.2. E2Eテストの責務と実装指針

E2Eテストは、ユーザーの操作を模倣することで、アプリケーション全体の正常性を保証する重要な役割を担います。しかし、その性質上、不安定になりやすく実行時間も長くなる傾向があるため、以下の責務と指針を定めます。

-   **テストの責務分担:**
    -   **ページ遷移のテスト (`tests/navigation.spec.ts`):** ページ間のリンクが正しく設定されていることを検証する責務を持ちます。実際の画面遷移を待つのではなく、リンク要素の`href`属性を検証することを原則とします。
    -   **各ゲームのE2Eテスト (`tests/{game-name}.spec.ts`):** 各ゲームページが直接開かれた状態から、そのページ内でのUI操作（コマを置く、リセットする等）が正しく機能することを検証する責務を持ちます。

-   **`pre-push`フックにおける注意点:**
    -   `git push`時に実行される`pre-push`フックは、開発者のローカル環境（インタラクティブなシェル）と異なる環境で動作する可能性があります。
    -   この環境差異により、特にクライアントサイドのナビゲーションを伴うテストが不安定になる場合があります。
    -   `pre-push`でE2Eテストが失敗し、原因の特定が困難な場合は、安易な待機処理を追加するのではなく、テストの実装方法（アサーションの仕方やテストの責務）そのものを見直すことを検討してください。

-   **`pre-push`フックにおける実行順序:**
    -   `pre-push`フックでは、`npm test`と`npm run build`が順に実行される。
    -   `npm test`には`lint`、`license`、`unit`、`e2e`の全てのチェックが含まれている。
    -   E2Eテストは内部的に開発サーバーを起動して実行されるため、`npm run build`の成果物には依存しない。したがって、`npm test`の後に`npm run build`を実行する現在の順序は、テストの安定性に影響を与えない合理的なものである。

### 4.3. テストコード内のコメントアウト

テストコード内に意図的に残されたコメントアウト部分は、将来のテスト実装の計画や、特定の条件下でのみ有効化すべきテストケース、あるいは過去のデバッグ過程で得られた知見など、重要なコンテキストを含んでいる場合があります。
これらのコメントアウトは、単なる不要なコードではなく、プロジェクトの知識資産として扱います。

-   **原則:** AI開発エージェントは、テストコード内のコメントアウトされたコードブロックを、人間の明確な指示なくして削除してはなりません。
-   **例外:** 自身の判断でコメントアウトを解除し、テストを有効化することは、その目的と意図が明確である場合に限り許可されます。


## 5. ログ管理

プロジェクトのログ管理に関する詳細は、[ログ管理ドキュメント](./technical-guide-log-management.md)を参照してください。

## 6. 未解決問題と課題の管理

プロジェクトの健全性を維持し、議論中に発生した未解決の問題や将来の課題が失われることを防ぐため、AIは以下の責務を負う。

-   **AIの責務:**
    -   タスクの完了時、またはセッションの終了時、AIはこれまでの議論をレビューし、**未解決の疑問、将来のタスク、または特定されたが即座に対処されなかった問題**がないかを確認しなければならない。
    -   そのような項目が発見された場合、AIは**自発的にGitHub Issueの作成を提案しなければならない。** 提案には、Issueのドラフトタイトルと説明文を含めること。


---
このドキュメントは、プロジェクトの進行に合わせて更新される可能性があります。常に最新の内容を確認してください。
この原則に基づき、常にプロジェクト全体の整合性を保つように努めてください。
---