
# ゲームアプリケーションのUI/UX改善と共通アーキテクチャ設計要件

## 1. 背景と課題

本プロジェクトは、複数のシンプルなボードゲームを提供するWebアプリケーションです。
現状、各ゲーム画面において、以下の課題が認識されています。

- **画面の圧迫感:** ゲームの状態を示すインジケーター（手番表示など）や、ルール確認・リセットといった補助的な操作ボタンが常に表示されており、特にスマートフォンのような狭い画面でゲームボードの表示領域を圧迫しています。
- **UI/UXの一貫性:** 今後さらにゲームを追加していくにあたり、ゲーム間でUI/UXの一貫性を保ち、ユーザーが直感的に操作できるデザインが求められます。
- **開発効率:** ゲームごとにUIコンポーネントを個別実装するのではなく、共通の仕組みを導入し、開発効率と保守性を向上させる必要があります。

## 2. デザイン要件

上記の課題を解決するため、以下の要件を満たすレスポンシブUIを設計・実装してください。

### 2.1. 基本方針

- **脱・ハンバーガーメニュー:** 安直なハンバーガーメニューに頼らず、よりモダンでコンテキストに適したUIパターンを採用します。
- **ゲームへの集中:** スマートフォンでは、プレイヤーがゲーム盤面に集中できるよう、補助的なUI要素はデフォルトで非表示にします。
- **PCでの一覧性:** PCでは、全ての情報・操作に素早くアクセスできる一覧性を確保します。

### 2.2. PC向けレイアウト (画面幅が広い場合)

- **サイドバーレイアウト**を採用します。
- **左サイドバー:** 画面左側に、以下の要素を格納した**コントロールパネル**を常時表示します。
    - 現在の状態（例：「白の番」）
    - スコアや取得した駒数などのインジケーター
    - 「ルールを見る」ボタン
    - 「リセット」ボタン
- **メインエリア:** 画面の残りの広い領域に、ゲームボードを表示します。

### 2.3. スマートフォン向けレイアウト (画面幅が狭い場合)

- **ミニマルレイアウト**を採用します。
- **ヘッダー:** 画面上部に、ゲームタイトルと現在の状態（例：「白の番」）のみを表示するスリムなバーを設置します。
- **ゲームボード:** 画面の大部分を占めるように表示します。
- **フローティングアクションボタン (FAB):** 画面右下などにメニューアイコン（例: ⚙️）を配置します。
- **ボトムシート/モーダル:** FABをタップすると、画面下からコントロールパネル（ルールボタン、リセットボタン等）がスライドアップして表示されます。

## 3. アーキテクチャ要件

デザインの実装に先立ち、今後の拡張性を見据え、ゲームを横断してライフサイクルやインジケーター類を共通制御できるアーキテクチャを設計・導入してください。

### 3.1. 設計目標

- **状態管理の共通化:** 「ゲームの状態（プレイ中, 決着など）」「現在の手番」「勝者」といった、どのゲームにも共通する状態を、統一された形式で扱えるようにします。
- **操作の共通化:** 「リセット」のような共通操作を、統一されたインターフェースで呼び出せるようにします。
- **責務の分離:**
    - **共通レイアウトコンポーネント (`GameLayout`):** 共通化された状態の描画（インジケーター等）と、共通操作の実行（リセットボタン等）に責務を持つ。
    - **個別ゲームコンポーネント:** ゲーム盤面の描画と、そのゲーム固有の操作に責務を集中させる。

### 3.2. 推奨アーキテクチャ案

- **共通の型定義:** `types/game.ts` に、ゲームの共通状態やコントローラーのインターフェースを定義します。

  ```typescript
  // in types/game.ts
  export type GameStatus = 'playing' | 'ended' | 'waiting';
  export type Player = string; // e.g., 'black', 'white', 'player1'

  // 全てのゲームが持つべき共通の状態
  export interface BaseGameState {
    status: GameStatus;
    currentPlayer: Player | null;
    winner: Player | null;
  }

  // 各ゲームのコアロジック（useGameフック）が準拠すべきインターフェース
  export interface GameController<TState extends BaseGameState, TAction> {
    gameState: TState;
    dispatch: React.Dispatch<TAction>;
  }
  ```

- **各ゲームの実装:** 各ゲームは、上記`GameController`インターフェースに準拠したカスタムフック（例: `useReversi`）を実装し、エクスポートします。

- **データフロー:**
  - ゲームページの親コンポーネント (`GameClientPage`) が、URLの`slug`に応じて適切な`useGame`フックと盤面コンポーネントを動的に読み込みます。
  - `useGame`フックから得られた`gameState`と`dispatch`を`GameLayout`コンポーネントに渡します。
  - `GameLayout`は、受け取った情報をもとに共通UIを描画し、子要素として盤面コンポーネントを描画します。

## 4. 次のステップ

以上の要件定義に基づき、具体的な実装計画を立て、開発に着手してください。
